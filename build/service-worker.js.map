{"mappings":"A,C,K,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,A,C,E,E,Q,A,E,Q,S,C,C,C,ECMA,IAAM,EAAe,wBACf,EAAgB,yBAGhB,EAAgB,CAClB,KACA,eAGH,CAKD,KAAK,gBAAgB,CAAC,UAAW,AAAC,IAC9B,QAAQ,GAAG,CAAC,kCAEZ,EAAM,SAAS,CACX,OAAO,IAAI,CAAC,GACP,IAAI,CAAC,AAAC,IACH,QAAQ,GAAG,CAAC,0CACL,EAAM,MAAM,CAAC,KAEvB,IAAI,CAAC,KACF,QAAQ,GAAG,CAAC,iCACL,KAAK,WAAW,KAE1B,KAAK,CAAC,AAAC,IACJ,QAAQ,KAAK,CAAC,wCAAyC,EAC3D,GAEZ,GAKA,KAAK,gBAAgB,CAAC,WAAY,AAAC,IAC/B,QAAQ,GAAG,CAAC,kCAEZ,EAAM,SAAS,CACX,OAAO,IAAI,GACN,IAAI,CAAC,AAAC,GACI,QAAQ,GAAG,CACd,EAAW,GAAG,CAAC,AAAC,IACZ,GAAI,IAAc,GAAgB,IAAc,EAE5C,OADA,QAAQ,GAAG,CAAC,uCAAwC,GAC7C,OAAO,MAAM,CAAC,EAE7B,KAGP,IAAI,CAAC,KACF,QAAQ,GAAG,CAAC,qCACL,KAAK,OAAO,CAAC,KAAK,KAGzC,GAMA,KAAK,gBAAgB,CAAC,QAAS,AAAC,IAEC,QAAzB,EAAM,OAAO,CAAC,MAAM,EAKnB,EAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,SAIlC,EAAM,WAAW,CACb,OAAO,KAAK,CAAC,EAAM,OAAO,EACrB,IAAI,CAAC,AAAC,GACH,AAAI,GACA,QAAQ,GAAG,CAAC,uCAAwC,EAAM,OAAO,CAAC,GAAG,EAC9D,GAIJ,MAAM,EAAM,OAAO,CAAC,KAAK,IAC3B,IAAI,CAAC,AAAC,IAEH,GAAI,CAAC,GAAY,AAAoB,MAApB,EAAS,MAAM,EAAY,AAAkB,UAAlB,EAAS,IAAI,CACrD,OAAO,EAIX,IAAM,EAAkB,EAAS,KAAK,GAStC,OANA,OAAO,IAAI,CAAC,GACP,IAAI,CAAC,AAAC,IACH,QAAQ,GAAG,CAAC,yCAA0C,EAAM,OAAO,CAAC,GAAG,EACvE,EAAM,GAAG,CAAC,EAAM,OAAO,CAAE,EAC7B,GAEG,CACX,GACC,KAAK,CAAC,AAAC,IACJ,QAAQ,KAAK,CAAC,iCAAkC,GAGzC,OAAO,KAAK,CAAC,mBAI5C,GAKA,KAAK,gBAAgB,CAAC,UAAW,AAAC,IAC1B,EAAM,IAAI,EAAI,AAAoB,iBAApB,EAAM,IAAI,CAAC,IAAI,EAC7B,KAAK,WAAW,EAExB,E,G,E,Q,C","sources":["<anon>","src/service-worker.js"],"sourcesContent":["(() => {\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire7677\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire7677\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"ezAIq\", function(module, exports) {\n/**\n * Service Worker for Power Meter PWA\n * Handles caching and offline functionality\n */ const $a9c0d08296ac1ab0$var$CACHE_NAME = 'power-meter-v1';\nconst $a9c0d08296ac1ab0$var$STATIC_CACHE = 'power-meter-static-v1';\nconst $a9c0d08296ac1ab0$var$DYNAMIC_CACHE = 'power-meter-dynamic-v1';\n// Files to cache on install\nconst $a9c0d08296ac1ab0$var$STATIC_ASSETS = [\n    './',\n    './index.html'\n];\n/**\n * Install event - cache static assets\n */ self.addEventListener('install', (event)=>{\n    console.log('[Service Worker] Installing...');\n    event.waitUntil(caches.open($a9c0d08296ac1ab0$var$STATIC_CACHE).then((cache)=>{\n        console.log('[Service Worker] Caching static assets');\n        return cache.addAll($a9c0d08296ac1ab0$var$STATIC_ASSETS);\n    }).then(()=>{\n        console.log('[Service Worker] Skip waiting');\n        return self.skipWaiting();\n    }).catch((error)=>{\n        console.error('[Service Worker] Installation failed:', error);\n    }));\n});\n/**\n * Activate event - clean up old caches\n */ self.addEventListener('activate', (event)=>{\n    console.log('[Service Worker] Activating...');\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        return Promise.all(cacheNames.map((cacheName)=>{\n            if (cacheName !== $a9c0d08296ac1ab0$var$STATIC_CACHE && cacheName !== $a9c0d08296ac1ab0$var$DYNAMIC_CACHE) {\n                console.log('[Service Worker] Deleting old cache:', cacheName);\n                return caches.delete(cacheName);\n            }\n        }));\n    }).then(()=>{\n        console.log('[Service Worker] Claiming clients');\n        return self.clients.claim();\n    }));\n});\n/**\n * Fetch event - serve from cache, fallback to network\n * Strategy: Cache First with Network Fallback\n */ self.addEventListener('fetch', (event)=>{\n    // Skip non-GET requests\n    if (event.request.method !== 'GET') return;\n    // Skip chrome-extension and other non-http requests\n    if (!event.request.url.startsWith('http')) return;\n    event.respondWith(caches.match(event.request).then((cachedResponse)=>{\n        if (cachedResponse) {\n            console.log('[Service Worker] Serving from cache:', event.request.url);\n            return cachedResponse;\n        }\n        // Clone the request because it can only be used once\n        return fetch(event.request.clone()).then((response)=>{\n            // Check if valid response\n            if (!response || response.status !== 200 || response.type === 'error') return response;\n            // Clone the response because it can only be used once\n            const responseToCache = response.clone();\n            // Cache the fetched response for future use\n            caches.open($a9c0d08296ac1ab0$var$DYNAMIC_CACHE).then((cache)=>{\n                console.log('[Service Worker] Caching new resource:', event.request.url);\n                cache.put(event.request, responseToCache);\n            });\n            return response;\n        }).catch((error)=>{\n            console.error('[Service Worker] Fetch failed:', error);\n            // Return a custom offline page if available\n            return caches.match('./index.html');\n        });\n    }));\n});\n/**\n * Message event - handle messages from clients\n */ self.addEventListener('message', (event)=>{\n    if (event.data && event.data.type === 'SKIP_WAITING') self.skipWaiting();\n});\n\n});\n\n\nparcelRequire(\"ezAIq\");\n})();\n//# sourceMappingURL=service-worker.js.map\n","/**\n * Service Worker for Power Meter PWA\n * Handles caching and offline functionality\n */\n\nconst CACHE_NAME = 'power-meter-v1';\nconst STATIC_CACHE = 'power-meter-static-v1';\nconst DYNAMIC_CACHE = 'power-meter-dynamic-v1';\n\n// Files to cache on install\nconst STATIC_ASSETS = [\n    './',\n    './index.html',\n    // Note: Parcel will bundle and hash the actual JS/CSS files\n    // These will be cached dynamically on first fetch\n];\n\n/**\n * Install event - cache static assets\n */\nself.addEventListener('install', (event) => {\n    console.log('[Service Worker] Installing...');\n\n    event.waitUntil(\n        caches.open(STATIC_CACHE)\n            .then((cache) => {\n                console.log('[Service Worker] Caching static assets');\n                return cache.addAll(STATIC_ASSETS);\n            })\n            .then(() => {\n                console.log('[Service Worker] Skip waiting');\n                return self.skipWaiting();\n            })\n            .catch((error) => {\n                console.error('[Service Worker] Installation failed:', error);\n            })\n    );\n});\n\n/**\n * Activate event - clean up old caches\n */\nself.addEventListener('activate', (event) => {\n    console.log('[Service Worker] Activating...');\n\n    event.waitUntil(\n        caches.keys()\n            .then((cacheNames) => {\n                return Promise.all(\n                    cacheNames.map((cacheName) => {\n                        if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {\n                            console.log('[Service Worker] Deleting old cache:', cacheName);\n                            return caches.delete(cacheName);\n                        }\n                    })\n                );\n            })\n            .then(() => {\n                console.log('[Service Worker] Claiming clients');\n                return self.clients.claim();\n            })\n    );\n});\n\n/**\n * Fetch event - serve from cache, fallback to network\n * Strategy: Cache First with Network Fallback\n */\nself.addEventListener('fetch', (event) => {\n    // Skip non-GET requests\n    if (event.request.method !== 'GET') {\n        return;\n    }\n\n    // Skip chrome-extension and other non-http requests\n    if (!event.request.url.startsWith('http')) {\n        return;\n    }\n\n    event.respondWith(\n        caches.match(event.request)\n            .then((cachedResponse) => {\n                if (cachedResponse) {\n                    console.log('[Service Worker] Serving from cache:', event.request.url);\n                    return cachedResponse;\n                }\n\n                // Clone the request because it can only be used once\n                return fetch(event.request.clone())\n                    .then((response) => {\n                        // Check if valid response\n                        if (!response || response.status !== 200 || response.type === 'error') {\n                            return response;\n                        }\n\n                        // Clone the response because it can only be used once\n                        const responseToCache = response.clone();\n\n                        // Cache the fetched response for future use\n                        caches.open(DYNAMIC_CACHE)\n                            .then((cache) => {\n                                console.log('[Service Worker] Caching new resource:', event.request.url);\n                                cache.put(event.request, responseToCache);\n                            });\n\n                        return response;\n                    })\n                    .catch((error) => {\n                        console.error('[Service Worker] Fetch failed:', error);\n\n                        // Return a custom offline page if available\n                        return caches.match('./index.html');\n                    });\n            })\n    );\n});\n\n/**\n * Message event - handle messages from clients\n */\nself.addEventListener('message', (event) => {\n    if (event.data && event.data.type === 'SKIP_WAITING') {\n        self.skipWaiting();\n    }\n});\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$a9c0d08296ac1ab0$var$STATIC_CACHE","$a9c0d08296ac1ab0$var$DYNAMIC_CACHE","$a9c0d08296ac1ab0$var$STATIC_ASSETS","self","addEventListener","event","console","log","waitUntil","caches","open","then","cache","addAll","skipWaiting","catch","error","keys","cacheNames","Promise","all","map","cacheName","delete","clients","claim","request","method","url","startsWith","respondWith","match","cachedResponse","fetch","clone","response","status","type","responseToCache","put","data"],"version":3,"file":"service-worker.js.map"}